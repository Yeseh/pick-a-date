import type { NextPage } from "next";
import Head from "next/head";
import { useRouter } from "next/router";
import { trpc } from "../../utils/trpc";
import * as dateFns from "date-fns";
import { capitalize, checkedToValueMapper } from "../../utils";
import { useState } from "react";
import { dayPartKeys } from "../../utils";

type DayPart = "morning" | "day" | "night" | "none";

const useInput = (def) => {
  const [value, setValue] = useState(def);
  const onChange = (e) => setValue(e.target.value);
  return {
    value,
    onChange,
  };
};

const getDateCheck = (dayname: string): ((date: Date) => boolean) => {
  const key = `is${capitalize(dayname)}`;
  const fn = (dateFns as any)[key];

  if (typeof fn === "function") {
    return fn;
  }

  throw new Error("Could not find datecheck function with key " + key);
};

const getDates = (rootDate: Date, possbileDays: string[], maxDates: number) => {
  const dates = [] as Date[];
  let currentDate = rootDate;

  // TODO: This is pretty na√Øeve and inefficient still :)
  while (dates.length < maxDates) {
    for (const day of possbileDays) {
      const isRightDay = getDateCheck(day);
      if (isRightDay(currentDate)) {
        dates.push(currentDate);
      }
    }

    currentDate = dateFns.add(currentDate, { days: 1 });
  }

  return dates;
};

type Answer = {
  date: Date;
  dayParts: DayPart[];
};

const Page: NextPage = () => {
  const router = useRouter();
  const { key } = router.query as { key: string };
  const nameInput = useInput("anonymous");
  const [answers, setAnswers] = useState([] as Answer[]);
  const getPad = trpc.useQuery(["pad.get", { key }]);
  const saveAnswers = trpc.useMutation("pad.answer");
  const pad = getPad.data;

  if (!getPad?.data) {
    return (
      <main>
        <div>
          <h1 className="text-5xl md:text-[5rem] leading-normal font-extrabold text-gray-700">
            Loading <span className="text-purple-300">Date</span>...
          </h1>
        </div>
      </main>
    );
  }

  const createAnswerSetter =
    (idx: number) => (date: Date, dayParts: DayPart[]) => {
      const updated = [...answers];
      updated[idx] = {
        date,
        dayParts,
      };
      setAnswers(updated);
    };

  const dates = getDates(pad!.rootDate, pad!.possibleDays, pad!.optionsAmount);

  // Initialize answers
  const newAnswers = [] as Answer[];
  for (const date of dates) {
    newAnswers.push({
      date,
      dayParts: [] as DayPart[],
    });
  }
  // setAnswers(newAnswers);

  const onSubmitAnswer = async () => {
    if (answers.length === dates.length) {
      const data = {
        name: nameInput.value,
        key,
        answers,
      };
      const red = await saveAnswers.mutateAsync(data);
      await router.push(red.redirect);
    } else {
      alert("Not every question is answered");
    }
  };

  return (
    <>
      <Head>
        <title>Pick A Date</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="container mx-auto flex flex-col items-center justify-center min-h-screen p-4">
        <h1 className="text-5xl md:text-[5rem] leading-normal font-extrabold text-gray-700">
          When are you <span className="text-purple-300">Available</span>?
        </h1>
        <div>
          <input
            {...nameInput}
            id="nameInput"
            type="text"
            value={nameInput.value}
            disabled={pad?.anonymous ?? true}
          />
        </div>
        {dates.map((date, idx) => (
          <div key={idx}>
            <Option
              date={date}
              possibleDayParts={pad!.possibleDayParts}
              answerSetter={createAnswerSetter(idx)}
            ></Option>
          </div>
        ))}
        <div className="text-5xl md:text-[5rem] leading-normal font-extrabold text-gray-800">
          <input
            id="createPadBtn"
            value="Submit"
            type="button"
            onClick={onSubmitAnswer}
          />
        </div>
      </main>
    </>
  );
};

type OptionProps = {
  date: Date;
  possibleDayParts: string[];
  answerSetter: (date: Date, dateParts: DayPart[]) => void;
};

const Option = ({ date, possibleDayParts, answerSetter }: OptionProps) => {
  const initialDayParts = possibleDayParts.map((d) => false);
  const [dayParts, setDayParts] = useState(initialDayParts);
  const [unavailable, setUnavailable] = useState(false);

  const toggleUnavailable = () => {
    const isUnavailable = !unavailable;
    if (isUnavailable) {
      // Clear available
      setDayParts(initialDayParts);
      answerSetter(date, ["none"]);
    }
    setUnavailable(!unavailable);
  };

  const mapBoolsToDayparts = checkedToValueMapper(possibleDayParts);

  const checkDayPart = (e: any, idx: number) => {
    const updated = [...dayParts];
    updated[idx] = !updated[idx];
    const mappedDayParts = updated
      .map(mapBoolsToDayparts)
      .filter((d) => d !== undefined);

    setDayParts(updated);
    answerSetter(date, mappedDayParts);
  };

  return (
    <>
      <div className="flex flex-row md:text-[3rem]">
        <h3 className="text-4xl md:text-[5rem] leading-normal font-extrabold text-gray-700 basis-1/">
          <span className="text-purple-300">
            {date.toLocaleDateString("nl-nl")}
          </span>
        </h3>
        <span>
          {possibleDayParts.map((part, idx) => (
            <span className="px-5" key={idx}>
              <input
                className="px-3"
                id={part}
                type="checkbox"
                name={part}
                checked={dayParts[idx]}
                disabled={unavailable}
                onChange={(e) => {
                  checkDayPart(e, idx);
                }}
              />
              <label htmlFor={part}>
                {possibleDayParts.length === 1 ? "Available" : capitalize(part)}
              </label>
            </span>
          ))}
          <span>
            <input
              id="una"
              type="checkbox"
              name="Unavailable"
              checked={unavailable}
              onChange={toggleUnavailable}
            />
            <label htmlFor="una">Not Available</label>
          </span>
        </span>
      </div>
    </>
  );
};

export default Page;
